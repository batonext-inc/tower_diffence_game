# タワーディフェンスゲーム

HTML + CSS + JavaScript（Vanilla）で実装したブラウザベースのタワーディフェンスゲームです。

## 🎮 ゲーム概要

10×10マスのフィールド上で、スタート地点からゴール（基地）へ向かってくる敵を、タワーを配置して撃退するタワーディフェンスゲームです。

### 主な特徴

- **完全なVanilla JavaScript実装**：React等のフレームワーク不要
- **静的ホスティング対応**：GitHub Pages / Netlify / Vercel等で簡単にデプロイ可能
- **Canvas 2D レンダリング**：軽量で高速な描画
- **2種類のタワー**：剣士（近接）とアーチャー（遠隔）
- **8方向/4方向スプライト対応**：タワーが敵の方向を向く
- **5ステージ構成**：ステージをクリアするごとに難易度が上昇
- **ウェーブクリアシステム**：各Wave完了時に3秒間の待機時間とクリア表示
- **マルチウェーブ**：各ステージ2-3のウェーブで構成
- **タワーアップグレード機能**：建設済みタワーをクリックしてレベルアップ
- **ゲーム速度調整**：×0.5、×1.0、×2.0の3段階

### ゲームルール

1. **初期ゴールド（G）**を使ってタワーを建設
2. **5種類の敵**（スライム、ゴブリン、盗賊、ゴーレム、魔王）がスタート地点から出現
3. **タワー**が自動的に射程内の敵を攻撃
4. 敵を倒すと**報酬G**を獲得
5. 敵が**基地（ゴール）**に到達すると基地を攻撃
6. **基地HPが0**になるとゲームオーバー
7. **全ウェーブをクリア**するとステージクリア、次のステージへ進行
8. **ステージ5をクリア**するとゲーム完全制覇

## 📁 ファイル構成

```
tower_diffence_game/
├── README.md                   # このファイル
├── public/
│   ├── index.html              # エントリーポイント
│   └── assets/
│       └── sprites/            # ゲーム画像
│           ├── ally/
│           │   ├── archer/     # アーチャー8方向（u,d,l,r,lu,ld,ru,rd）
│           │   ├── solder/     # 剣士4方向（u,d,l,r）
│           │   └── tower.png   # 基地画像
│           └── enemy/
│               ├── slime.png
│               ├── goblin.png
│               ├── thief.png
│               ├── golem.png
│               └── demon_king.png
└── src/
    ├── main.js                 # メインゲームロジック
    ├── core/                   # コアシステム
    │   ├── engine.js           # ゲームループ・タイミング管理
    │   ├── renderer.js         # Canvas描画ユーティリティ
    │   ├── assetLoader.js      # 画像読み込み
    │   └── input.js            # マウス入力管理
    └── game/                   # ゲームロジック
        ├── map.js              # マップ・パス定義
        ├── entities.js         # エンティティ基底クラス
        ├── enemy.js            # 敵ロジック（5種類）
        ├── tower.js            # タワー・弾ロジック（2種類）
        ├── base.js             # 基地ロジック
        ├── wave.js             # ウェーブ管理
        ├── economy.js          # ゴールド管理
        ├── stage.js            # ステージ進行管理（5ステージ）
        ├── ui.js               # UI描画
        └── save.js             # セーブ/ロード（予約）
```

## 🚀 起動方法

### 必要要件

- モダンブラウザ（Chrome / Firefox / Safari / Edge 最新版）
- ローカルサーバー（CORS制限のため）

### 起動手順

#### 方法1: Python 3 を使用（推奨）

```bash
# プロジェクトルートディレクトリへ移動
cd /path/to/tower_diffence_game

# Pythonの簡易HTTPサーバーを起動
python3 -m http.server 8000

# ブラウザでアクセス
# http://localhost:8000/public/
```

#### 方法2: VS Code Live Server拡張機能

1. VS Codeに「Live Server」拡張機能をインストール
2. `public/index.html` を右クリック
3. 「Open with Live Server」を選択

#### 方法3: npx（Node.js環境）

```bash
# プロジェクトルートディレクトリで実行
npx serve public -p 8000

# ブラウザでアクセス
# http://localhost:8000/
```

## 🎯 ゲームシステム詳細

### タワータイプ

#### 剣士（Solder）
- **コスト**: 30G
- **アップグレードコスト**: 20G
- **射程**: 120px
- **攻撃速度**: 1.5発/秒
- **ダメージ**: 5.5
- **特徴**: 近接型、4方向スプライト、赤い×エフェクト攻撃

#### アーチャー（Archer）
- **コスト**: 40G
- **アップグレードコスト**: 30G
- **射程**: 160px
- **攻撃速度**: 2.2発/秒
- **ダメージ**: 4
- **特徴**: 遠隔型、8方向スプライト、矢を発射

### 敵タイプ

#### スライム（Slime）
- **HP**: 30
- **速度**: 60 px/秒
- **報酬**: 5G
- **基地ダメージ**: 1/秒

#### ゴブリン（Goblin）
- **HP**: 45
- **速度**: 80 px/秒
- **報酬**: 8G
- **基地ダメージ**: 2/秒

#### 盗賊（Thief）
- **HP**: 60
- **速度**: 120 px/秒（高速）
- **報酬**: 10G
- **基地ダメージ**: 1/秒

#### ゴーレム（Golem）
- **HP**: 500（高耐久）
- **速度**: 40 px/秒（低速）
- **報酬**: 20G
- **基地ダメージ**: 3/秒

#### 魔王（Demon King）
- **HP**: 1800（最終ボス）
- **速度**: 50 px/秒
- **報酬**: 100G
- **基地ダメージ**: 5/秒

### ステージ構成

| ステージ | 初期G | ウェーブ数 | 主な敵 | クリア報酬 |
|---------|-------|-----------|--------|-----------|
| 1 | 100 | 2 | スライム | 30G |
| 2 | 継承 | 3 | スライム、ゴブリン | 40G |
| 3 | 継承 | 3 | スライム、ゴブリン、盗賊 | 50G |
| 4 | 継承 | 3 | ゴブリン、盗賊、ゴーレム | 80G |
| 5 | 継承 | 3 | 魔王 | 200G |

### UI構成

- **画面右サイドバー**: ゴールド、基地HP、ステージ、Wave、速度変更ボタン
- **画面下部HUD**: タワー選択ボタン（剣士・アーチャー）
- **ホバー時表示**: 建設コスト、アップグレードコスト、攻撃範囲
- **敵情報**: HP数値とHPバーが常に最前面に表示

### ゲーム進行

1. **ステージ開始**: 2秒後に最初の敵が出現
2. **Wave完了**: 全敵撃破後「Wave X Clear!!!」表示
3. **Wave間待機**: 現実時間3秒（ゲーム速度に影響されない）
4. **次Wave開始**: カウントダウン後、自動的に次Waveへ
5. **ステージクリア**: 最終Wave完了後、ボーナスG獲得

## 🕹️ 操作方法

### マウス操作

- **左クリック（空きタイル）**: タワーを建設
- **左クリック（建設済みタイル）**: タワーをアップグレード
- **ホバー**: コスト・攻撃範囲の表示

### 画面UI

- **速度ボタン（右サイドバー）**: ゲーム速度切り替え（×0.5/×1.0/×2.0）
- **タワー選択（下部HUD）**: 剣士またはアーチャーを選択

## 🛠️ 技術スタック

- **HTML5 Canvas**: レンダリング
- **ES Modules**: モジュール管理
- **requestAnimationFrame**: ゲームループ（60FPS）
- **Vanilla JavaScript**: フレームワーク不使用

### 主要アルゴリズム

- **パス追従**: ウェイポイント配列 + 線形補間
- **ターゲティング**: 最近接優先（Nearest）アルゴリズム
- **衝突判定**: 円形（Circle vs Circle）
- **描画最適化**: レイヤー分離（スプライト→HPバー→UI）
- **時間管理**: Wave Clear待機は現実時間（Date.now()）ベース

### コード設計

- **モジュラー構造**: 機能ごとにファイル分割
- **ES6クラス**: オブジェクト指向設計
- **状態管理**: GAME_STATE による明確な状態遷移
- **レンダラー分離**: 描画ロジックを Renderer クラスに集約

## 📝 カスタマイズガイド

### タワーの調整

`src/game/tower.js` の `TOWER_TYPES` を編集：

```javascript
export const TOWER_TYPES = {
  archer: {
    cost: 40,           // 建設コスト
    upgradeCost: 30,    // アップグレードコスト
    range: 160,         // 射程（ピクセル）
    fireRate: 2.2,      // 攻撃速度（発/秒）
    damage: 4,          // ダメージ
    // ...
  }
};
```

### 敵の調整

`src/game/enemy.js` の `ENEMY_TYPES` を編集：

```javascript
export const ENEMY_TYPES = {
  slime: {
    hp: 30,            // 体力
    speed: 60,         // 移動速度（px/秒）
    bounty: 5,         // 撃破報酬
    attackDamage: 1,   // 基地へのダメージ
    // ...
  }
};
```

### ステージの調整

`src/game/stage.js` の `initializeStages()` を編集：

```javascript
1: {
  startGold: 100,                    // 初期ゴールド
  waves: [
    {
      delay: 2.0,                    // Wave開始遅延（秒）
      enemies: [
        { type: 'slime', n: 10, interval: 0.8 }  // 敵タイプ、数、出現間隔
      ]
    }
  ],
  clearBonusGold: 30                 // クリアボーナス
}
```

### Wave Clear待機時間の調整

`src/game/wave.js` の18行目：

```javascript
this.waveClearDelay = 3000; // ミリ秒単位（現実時間）
```

### マップ経路の調整

`src/game/map.js` の `path` 配列を編集：

```javascript
export const path = [
  { x: -1, y: 1 },  // 画面外スタート
  { x: 0, y: 1 },
  // ... 経路を追加
  { x: 9, y: 4 }    // ゴール
];
```

## 📄 ライセンス

このプロジェクトは学習・セミナー用途で作成されています。

---

**Happy Tower Defense! 🏰⚔️🛡️**

# 対戦機能

このゲームには、ブラウザ間でキャンバス映像をP2P共有し、相手の画面をリアルタイムで表示できる簡易対戦機能（観戦/対戦下地）が追加されています。WebRTCを使用し、手動シグナリングで接続します。

## 概要

- **P2P接続（WebRTC）**：Google Public STUNを使用。基本的にポート開放は不要です。
- **2画面表示**：自分のゲーム画面（Canvas）は通常通り、相手の画面は右サイドバー上に小画面で表示されます。
- **キャンバス映像共有**：`canvas.captureStream()`でゲーム映像をストリーム化して送信。
- **DataChannel準備**：将来的なゲーム状態同期/コマンド同期のためにDataChannelも作成（現状は未使用）。

## 使い方（手動シグナリング）

1. 画面右上の「P2P」ボタンを押して接続パネルを開きます。
2. どちらか一方が「ホスト（Offer生成）」をクリックし、生成されたOffer（SDP）をコピーして相手に送ります。
3. 参加側は「相手のOfferを貼り付け」にOfferを貼り、「Offerを適用」または「参加（Answer生成）」を押してAnswerを生成します。
4. 参加側で生成されたAnswer（SDP）をホストへ送り、ホストは「相手のAnswerを貼り付け」に貼って「Answerを適用」します。
5. 数秒待つとP2P接続が確立され、右サイドバー上に相手の画面（`peer-video`）が表示されます。切断は「切断」ボタンで可能です。

## できること / 制限

- できること
  - 相手のゲーム画面をリアルタイムで観戦（低遅延のP2P映像）。
  - 将来的な対戦同期に備えたDataChannelの土台あり。
- 現時点の制限
  - 各プレイヤーのゲーム進行は独立（映像のみ共有）。スコア・敵Wave・操作の同期は未実装。
  - シグナリングは手動（Offer/Answerをチャット等で交換）。

## 実装ファイル

- `index.html`
  - P2P接続パネル（Offer/Answer UI）と相手映像用`<video id="peer-video">`を追加。
- `src/net/webrtc.js`
  - `WebRTCManager`：`RTCPeerConnection`の生成、手動シグナリング、Canvasストリーム送受信、DataChannel管理。
- `src/main.js`
  - 起動時にCanvasから映像ストリームを生成して送信準備。WebRTC UIのボタンイベントを接続処理にバインド。受信映像を`peer-video`に表示。

## 今後の拡張案

- DataChannelでゲーム状態（敵の出現、タワー設置、乱数シード）を同期し、完全な対戦/協力モードへ拡張。
- シグナリングサーバー（WebSocket）を導入してOffer/Answerの交換を自動化。
- 双方向の音声/テキストチャット追加（必要に応じて）。

## 設計検討：P2Pは適している？他方式との比較

### 結論（要約）
- 1対1・カジュアル・低コストなら、P2P（WebRTC DataChannel/Media）は現実的。
- 公開運用・モバイル混在・ランク戦/不正対策が必要なら、サーバ権威（オーソリタティブ）方式が無難。
- 観戦者が多数なら、映像配信はP2PよりSFU（配信サーバ）の検討が必要。

### 主要方式のPros/Cons

- P2P（WebRTC DataChannel/Media）
  - Pros
    - 低レイテンシ（端末間が近ければ有利）
    - シグナリング以外のサーバ運用がほぼ不要で低コスト
    - 1対1なら端末帯域負荷が小さくスケールしやすい
  - Cons
    - NAT越え失敗時はTURNが必要（サーバ帯域コストが発生）
    - 不正対策が難しい（クライアント権限が強い）
    - 接続切断や品質変動のハンドリング・再同期実装が必要
    - 多人数観戦/多者対戦で送信側帯域が逼迫しやすい

- オーソリタティブ・サーバ（WebSocket/UDPなど）
  - Pros
    - 不正対策・一貫性・復旧（ロールバック/リカバリ）が実装しやすい
    - NAT問題をサーバが吸収し接続が安定
    - 観戦・リプレイ・マッチメイク等の拡張が容易
  - Cons
    - サーバ運用コスト（インフラ/保守）
    - レイテンシはサーバ往復に依存
    - 実装コスト（サーバで状態計算 or 入力仲介＋検証）

- P2P + TURNリレー
  - Pros: P2P失敗ケースでも接続可（企業ネット/キャリアNAT対策）
  - Cons: 実質サーバ帯域コストが発生し、P2Pの旨味が薄れる

- 決定的ロックステップ（入力同期＋乱数シード共有）
  - Pros: 帯域極小・2者なら低コストで高い同期精度、P2P/サーバどちらにも載せやすい
  - Cons: 完全決定的なゲームロジック設計が必要（浮動小数/時間依存の排除）、ラグ時の体験ケアが必要

- ロールバック方式（GGPO的）
  - Pros: 主観的な操作応答が軽快（体感低遅延）
  - Cons: 実装難度が高い（過去状態の保持と再シミュレーション）

- 観戦配信：P2P vs SFU（mediasoup/Janus等）
  - P2P映像
    - Pros: 低コスト、2者なら実装簡単
    - Cons: 観戦者が増えると送信者の帯域が枯渇
  - SFU
    - Pros: 多人数にスケール、帯域効率が良い
    - Cons: サーバ運用/実装が必要

### このプロジェクト向けの指針
- まずは「1対1＋観戦小規模」をP2Pで素早く成立させる（現状の実装方針）。
- 次のステップとして、DataChannel上で「入力同期＋乱数シード共有（軽量ロックステップ）」を導入し、ゲーム状態も同期。
- 公開運用や競技性を高める場合は、サーバ権威方式へ移行（入力をサーバで検証・状態配信）。観戦はSFUで拡張。
