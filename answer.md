いいね！要件は明確なので、「最小プレイ可能版 → コア機能実装 → コンテンツ拡張 → 仕上げ・配信」の順で進めると、迷いなく完成まで走れます。HTML/CSS/JavaScript（ES Modules）＋Canvas 2D を前提に、実践的な手順をまとめました。

# 全体像（ロードマップ）

1. 企画固め（半日）
2. 最小プレイ可能版（MVP）構築：マップ描画・敵が進む・基地HPが減る（1〜2日）
3. タワー基盤：設置・射程・攻撃・コスト・G管理（1〜2日）
4. ウェーブ／ステージ進行：クリア→次ステージ・報酬G（1日）
5. アセット導入：画像ローダー、当たり判定と見た目の同期（1日）
6. UI/UX：HUD、ビルドUI、ポーズ、速度変更（1日）
7. バランス調整・難易度カーブ・保存（2〜3日）
8. 仕上げ：効果音・アニメ・最適化・バグ潰し・デプロイ（1〜2日）

---

# 1. 企画・技術選定

* **レンダリング**：`<canvas>` + Canvas 2D。DOMでも実装できるが、スプライト多数＆発射体でCanvasが軽量。
* **マップ**：10×10 タイル。PCでは1タイル＝64px固定。スマホでは画面幅に合わせて縮小。
* **パス**：スタート→ゴールの一本道は**ウェイポイント配列**（`[{x,y}, ...]`）で管理。A*不要。
* **ゲームループ**：`requestAnimationFrame`、固定または可変Δt（60FPS想定）。
* **ファイル構成（例）**

  ```
  /public
    index.html
    /assets
      /sprites   (敵/タワー/基地PNG)
      /ui        (アイコン・ボタン)
      /sfx       (効果音)
  /src
    main.js           (エントリ、ループ)
    core/
      engine.js       (タイミング、シーン管理)
      renderer.js     (描画ユーティリティ)
      assetLoader.js  (画像/音読み込み)
      input.js        (マウス/タッチ)
    game/
      map.js          (タイル/パス)
      entities.js     (共通ベース：位置/HP等)
      enemy.js        (敵ロジック)
      tower.js        (タワー/弾/ターゲティング)
      base.js         (最終基地)
      wave.js         (スポナー/ウェーブ定義)
      economy.js      (G管理/購入/売却/強化)
      stage.js        (進行/報酬/難易度)
      ui.js           (HUD/ビルドメニュー)
      save.js         (localStorage)
  ```

---

# 2. データ設計（最初に軽く決めておく）

* **マップ & パス**

  ```js
  export const TILE_SIZE = 64; // px
  export const map10x10 = [
    // 0:地形, 1:道, 2:建設可(草原) 等
  ];
  export const path = [ {x:0,y:4}, {x:1,y:4}, ... , {x:9,y:4} ]; // 一直線例
  export const start = { x:0, y:4 };
  export const goal  = { x:9, y:4 };
  ```
* **敵**

  ```js
  {
    type: 'slime',
    hp: 30, maxHp: 30,
    speed: 60, // px/sec
    bounty: 5, // 撃破G
    pos: {x,y}, pathIndex: 0,
    spriteId: 'enemy_slime'
  }
  ```
* **基地**

  ```js
  {
    hp: 20, maxHp: 20,
    pos: goalWorldPos,
    spriteId: 'base_core'
  }
  ```

  ※「敵が基地に到達したら**倒されるまで基地へ継続ダメージ**」という要件：
  到達後は**攻撃状態**に移行し、`dps`や`attackInterval`で基地HPを削る。基地側にノックバックは無し。タワーが撃破するまで続く。
* **タワー**

  ```js
  {
    type: 'arrow',
    level: 1,
    cost: 20, upgradeCost: 25,
    range: 120, fireRate: 1.0, // 発/秒
    damage: 8,
    pos: {x,y}, tile:{tx,ty},
    targetMode: 'first|strong|closest',
    spriteId: 'tower_arrow'
  }
  ```
* **ウェーブ/ステージ**

  ```js
  // ステージごとにウェーブ配列
  const stage1 = {
    startGold: 50,
    waves: [
      { delay: 0,   enemies: [ {type:'slime', n:10, interval:0.6} ] },
      { delay: 6.0, enemies: [ {type:'slime', n:15, interval:0.5} ] },
    ],
    clearBonusGold: 30
  };
  ```

---

# 3. MVP（最小プレイ可能版）

* 10×10マップを描画（グリッド＋道の画像敷き）。
* 敵をスタートへスポーン → ウェイポイント補間で移動 → ゴールで基地HP減少。
* 基地HPが0でゲームオーバー、全敵処理でステージクリア（仮UIでOK）。
* 画像は一旦プレースホルダー（色ブロック）でもOK。**動く体験を先に作る**。

---

# 4. タワー基盤の実装

* **設置**：建設可能タイルをハイライト。クリックでプレビュー→確定でG消費。
* **ターゲティング**：`first/strong/closest` の一つから開始（MVPは`first`のみでもOK）。
* **攻撃**：`fireRate`管理、`projectile`（弾）生成→敵へ当たり判定（円判定で十分）。
* **アップグレード**：レベルごとに `damage/range/fireRate` など上昇、コストは指数的に。
* **売却（任意）**：戻りGは購入合計の50〜70%。

---

# 5. ウェーブ／ステージ進行

* **ウェーブ管理**：予定テーブルに沿って敵を一定間隔スポーン。
* **ステージクリア判定**：全ウェーブ出現済＋生存敵0。
* **報酬**：`clearBonusGold` 付与、**次ステージ**のボタンをアクティブ化。
* **進行保存**：`localStorage` に `currentStage` と `gold`、オプションでタワー配置スナップショット。

---

# 6. 画像アセット導入

* **スプライトサイズ統一**（例 48×48）。アンカーポイント中心で衝突と一致させる。
* **ロード**：簡易アセットローダー（`Promise.all(Image)`）→読み込み完了でスタート。
* **アニメ**（任意）：歩行は2〜4枚ループ、当たり判定はAABB or 円。

---

# 7. UI/UX

* **HUD**：G、基地HP、ステージ番号、ウェーブ進捗（バー/カウンタ）。
* **ビルドメニュー**：タワー種類、コスト、簡単な説明、購入/アップグレード。
* **ポーズ**、**ゲーム速度×2**、**リトライ**、**次ステージへ**。
* **フィードバック**：ダメージポップ、ヒットフラッシュ、設置時SE、クリア時演出。

---

# 8. 数値設計・バランスの叩き台

* タイル 48px、敵速度 60px/s → 1マス0.8s 目安。
* ウェーブ間隔 6〜12s、1ウェーブあたり20体前後。
* タワー初期射程 120px、DPSは1ウェーブの総HPに対して**7〜9割**を基本、残りはプレイヤースキルで補う。
* ステージ進行で**敵HP/速度/DPS**を逓増、クリアボーナスGも逓増。
* 基地HPは序盤緩め（20〜30）、後半は敵DPS上昇で緊張感。

---

# 9. セーブ／ロード

* `localStorage`：`{stage: n, gold: x, difficulty: 'normal', options:{sfx:true}}`
* 自動保存は**ステージ終了時**、手動セーブは任意。

---

# 10. テスト計画

* **単体**：パス追従（曲がり角での補間）、弾の衝突、売買計算、金額の境界値。
* **統合**：60FPSでのスパイク（大量スポーン時）、ポーズ/速度切り替え。
* **UX**：設置ミス防止（禁止タイルへの配置拒否）、誤クリック対策（確定操作）。

---

# 11. 最適化（必要に応じて）

* **スプライトバッチ**：Canvasは基本逐次描画だが、静的層（地形/道）は**オフスクリーンCanvasに事前描画**して使い回す。
* **オブジェクトプール**：弾やヒットエフェクトをプーリング。
* **当たり判定の空間分割**：タワー毎に近傍敵のみチェック（セル分割 or グリッドバケツ）。

---

# 12. 品質向上（仕上げ）

* 効果音（発射/命中/クリア/被弾）、簡易BGM（ミュート切替）。
* 画面サイズ可変：**固定解像度＋等倍/整数スケール**でボケ防止、スマホはピンチ無効化＋タッチ操作。
* アクセシビリティ：色依存UIの回避、被ダメ赤点滅の強度調整など。
* ライセンス表記（使用素材/フォント）。
* **静的ホスティング**：GitHub Pages / Netlify / Vercel へ配置（ビルド不要、ESM直読み）。

  * 例：`<script type="module" src="/src/main.js"></script>`
  * キャッシュ対策にリビジョン付きクエリ `?v=YYYYMMDD`.

---

# 参考となる最初の実装順チェックリスト

* [ ] ループと描画（土台）
* [ ] マップ静的レイヤーのオフスクリーン描画
* [ ] パス追従の敵（1種）と基地ダメージ
* [ ] Gの増減（初期配布・撃破・クリア）
* [ ] タワー設置・攻撃・弾
* [ ] ウェーブ/ステージ遷移
* [ ] 画像読み込み＆差し替え
* [ ] HUD/ビルドUI/ポーズ/速度
* [ ] セーブ/ロード
* [ ] チューニング＆最適化
* [ ] SFX/BGM・最終調整・デプロイ

---
